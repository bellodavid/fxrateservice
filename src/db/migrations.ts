import { Pool } from "pg";
import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";

dotenv.config();

// Supabase connection (for reference)
const supabaseUrl = process.env.SUPABASE_URL || "";
const supabaseKey = process.env.SUPABASE_ANON_KEY || "";
const supabase = createClient(supabaseUrl, supabaseKey);

// Direct PostgreSQL connection for migrations
const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  database: process.env.POSTGRES_DATABASE,
  user: process.env.POSTGRES_USER,
  password: process.env.POSTGRES_PASSWORD,
  port: parseInt(process.env.POSTGRES_PORT || "5432"),
  ssl: { rejectUnauthorized: false },
  connectionTimeoutMillis: 10000,
  query_timeout: 10000,
});

console.log('Attempting to connect to database:', {
    host: process.env.POSTGRES_HOST,
    database: process.env.POSTGRES_DATABASE,
    user: process.env.POSTGRES_USER,
    port: process.env.POSTGRES_PORT
  });
  
// Migration functions
export async function createTables() {
  const client = await pool.connect();

  try {
    // Start transaction
    await client.query("BEGIN");

    // Create migrations table if it doesn't exist
    await client.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check if rate_history table exists
    const { rows } = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'rate_history'
      );
    `);

    if (!rows[0].exists) {
      console.log("Creating rate_history table...");

      // Create rate_history table
      await client.query(`
        CREATE TABLE rate_history (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          from_currency VARCHAR(3) NOT NULL,
          to_currency VARCHAR(3) NOT NULL,
          banana_crystal_rate DECIMAL(20,6) NOT NULL,
          confidence DECIMAL(5,2) NOT NULL,
          volatility_index DECIMAL(10,2) NOT NULL,
          is_stationary BOOLEAN NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
        );

        -- Create index for faster querying
        CREATE INDEX idx_rate_history_currency_pair 
        ON rate_history(from_currency, to_currency);

        -- Create index for timestamp-based queries
        CREATE INDEX idx_rate_history_created_at 
        ON rate_history(created_at DESC);

        -- Record migration
        INSERT INTO migrations (name) 
        VALUES ('create_rate_history_table');
      `);

      console.log("Rate history table created successfully!");
    } else {
      console.log("Rate history table already exists.");
    }

    // Commit transaction
    await client.query("COMMIT");
  } catch (error) {
    // Rollback in case of error
    await client.query("ROLLBACK");
    console.error("Error during migration:", error);
    throw error;
  } finally {
    // Release client back to pool
    client.release();
  }
}

// Function to drop tables (useful for testing/development)
export async function dropTables() {
  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    await client.query(`
      DROP TABLE IF EXISTS rate_history CASCADE;
      DROP TABLE IF EXISTS migrations CASCADE;
    `);

    await client.query("COMMIT");
    console.log("Tables dropped successfully!");
  } catch (error) {
    await client.query("ROLLBACK");
    console.error("Error dropping tables:", error);
    throw error;
  } finally {
    client.release();
  }
}

// Migration script
async function runMigrations() {
  try {
    await createTables();
    console.log("Migrations completed successfully!");
  } catch (error) {
    console.error("Migration failed:", error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

// Execute migrations if this file is run directly
if (require.main === module) {
  runMigrations();
}

async function runMigrationsWithRetry(retries = 3): Promise<void> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      await createTables();
      console.log("Migrations completed successfully!");
      return;
    } catch (error) {
      console.error(`Migration attempt ${attempt} failed:`, error);
      if (attempt < retries) {
        console.log("Retrying...");
        await new Promise((resolve) => setTimeout(resolve, 5000));
      } else {
        console.error("All migration attempts failed.");
        process.exit(1);
      }
    }
  }
}

if (require.main === module) {
  runMigrationsWithRetry();
}


export default { createTables, dropTables };
